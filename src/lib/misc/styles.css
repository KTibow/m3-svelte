@function --translucent(--color, --opacity) {
  result: oklab(from var(--color) l a b / var(--opacity));
}
/* DEPRECATED: This default --m3-density function will be removed in a future version.
   For new themes, pick which option you actually want. */
@function --m3-density(--size) {
  result: calc(var(--size) + (var(--m3v-density, 0) * 0.25rem));
}

@layer tokens {
  :root {
    /* Needed for elevation to work */
    --m3-elevation-0: none;
    --m3-elevation-1:
    /* Spot */
      0px 1px 2px 0px --translucent(var(--m3c-shadow), 0.3),
      /* Ambient */ 0px 1px 3px 1px --translucent(var(--m3c-shadow), 0.15);
    --m3-elevation-2:
      0px 1px 2px 0px --translucent(var(--m3c-shadow), 0.3),
      0px 2px 6px 2px --translucent(var(--m3c-shadow), 0.15);
    --m3-elevation-3:
      0px 1px 3px 0px --translucent(var(--m3c-shadow), 0.3),
      0px 4px 8px 3px --translucent(var(--m3c-shadow), 0.15);
    --m3-elevation-4:
      0px 2px 3px 0px --translucent(var(--m3c-shadow), 0.3),
      0px 6px 10px 4px --translucent(var(--m3c-shadow), 0.15);
    --m3-elevation-5:
      0px 4px 4px 0px --translucent(var(--m3c-shadow), 0.3),
      0px 8px 12px 6px --translucent(var(--m3c-shadow), 0.15);

    /* Shapes */
    --m3-shape-none: 0;
    --m3-shape-extra-small: 4px;
    --m3-shape-small: 8px;
    --m3-shape-medium: 12px;
    --m3-shape-large: 16px;
    --m3-shape-extra-large: 28px;
    --m3-shape-full: calc(infinity * 1px);
    --m3-optical-centering-coefficient: 0.11;

    /* Typography */
    --m3-font: Roboto, system-ui;
    --m3-font-mono: "Google Sans Code", "Roboto Mono", monospace;

    /* Expressive easing */
    --m3-timing-function-fast-spatial: cubic-bezier(0.42, 1.67, 0.21, 0.9);
    --m3-duration-fast-spatial: 350ms;
    --m3-easing-fast-spatial: var(--m3-timing-function-fast-spatial) var(--m3-duration-fast-spatial);

    --m3-timing-function-spatial: cubic-bezier(0.38, 1.21, 0.22, 1);
    --m3-duration-spatial: 500ms;
    --m3-easing-spatial: var(--m3-timing-function-spatial) var(--m3-duration-spatial);

    --m3-timing-function-slow-spatial: cubic-bezier(0.39, 1.29, 0.35, 0.98);
    --m3-duration-slow-spatial: 650ms;
    --m3-easing-slow-spatial: var(--m3-timing-function-slow-spatial) var(--m3-duration-slow-spatial);

    --m3-timing-function-fast: cubic-bezier(0.31, 0.94, 0.34, 1);
    --m3-duration-fast: 150ms;
    --m3-easing-fast: var(--m3-timing-function-fast) var(--m3-duration-fast);

    --m3-timing-function: cubic-bezier(0.34, 0.8, 0.34, 1);
    --m3-duration: 200ms;
    --m3-easing: var(--m3-timing-function) var(--m3-duration);

    --m3-timing-function-slow: cubic-bezier(0.34, 0.88, 0.34, 1);
    --m3-duration-slow: 300ms;
    --m3-easing-slow: var(--m3-timing-function-slow) var(--m3-duration-slow);

    --m3-timing-function-emphasized: linear(
      0,
      0.034 6%,
      0.073 9%,
      0.126 11%,
      0.194 13%,
      0.273 15%,
      0.351 16%,
      0.541 18%,
      0.652 20%,
      0.755 24%,
      0.839 30%,
      0.91 39%,
      0.959 53%,
      0.989 72%,
      1
    );
    --m3-timing-function-emphasized-accel: cubic-bezier(0.3, 0, 0.8, 0.15);
    --m3-timing-function-emphasized-decel: cubic-bezier(0.05, 0.7, 0.1, 1);

    --m3-timing-function-zeno: linear(
      0,
      0.08 1.5%,
      0.15 2.93%,
      0.22 4.48%,
      0.29 6.18%,
      0.35 7.77%,
      0.41 9.52%,
      0.47 11.45%,
      0.52 13.24%,
      0.57 15.22%,
      0.61 16.98%,
      0.65 18.93%,
      0.69 21.12%,
      0.73 23.61%,
      0.76 25.74%,
      0.79 28.14%,
      0.82 30.92%,
      0.84 33.05%,
      0.86 35.46%,
      0.88 38.24%,
      0.9 41.52%,
      0.92 45.55%,
      0.93 47.96%,
      0.95 54.02%,
      0.96 58.05%,
      0.97 63.24%,
      0.98 70.55%,
      0.99 83.05%,
      1
    );
  }
}
/* Not tokens because they may be dynamically get/set and aren't generally constant */
@property --m3v-bottom-offset {
  syntax: "<length>";
  inherits: true;
  initial-value: 0;
}
:root {
  --m3v-background: var(--m3c-surface);
}

/* As the largest text on the screen, display styles are reserved for short, important text or numerals. */
@mixin --m3-display-large {
  font-family: var(--m3-font);
  font-size: 3.563rem;
  line-height: 1.123;
  letter-spacing: 0;
  font-weight: 400;
}
@mixin --m3-display-medium {
  font-family: var(--m3-font);
  font-size: 2.813rem;
  line-height: 1.156;
  letter-spacing: 0;
  font-weight: 400;
}
@mixin --m3-display-small {
  font-family: var(--m3-font);
  font-size: 2.25rem;
  line-height: 1.222;
  letter-spacing: 0;
  font-weight: 400;
}

/* Headlines are best-suited for short, high-emphasis text on smaller screens. */
@mixin --m3-headline-large {
  font-family: var(--m3-font);
  font-size: 2rem;
  line-height: 1.25;
  letter-spacing: 0;
  font-weight: 400;
}
@mixin --m3-headline-medium {
  font-family: var(--m3-font);
  font-size: 1.75rem;
  line-height: 1.286;
  letter-spacing: 0;
  font-weight: 400;
}
@mixin --m3-headline-small {
  font-family: var(--m3-font);
  font-size: 1.5rem;
  line-height: 1.333;
  letter-spacing: 0;
  font-weight: 400;
}

/* Titles are smaller than headline styles, and should be used for medium-emphasis text that remains relatively short. */
@mixin --m3-title-large {
  font-family: var(--m3-font);
  font-size: 1.375rem;
  line-height: 1.273;
  letter-spacing: 0;
  font-weight: 400;
}
@mixin --m3-title-medium {
  font-family: var(--m3-font);
  font-size: 1rem;
  line-height: 1.5;
  letter-spacing: 0;
  font-weight: 500;
}
@mixin --m3-title-small {
  font-family: var(--m3-font);
  font-size: 0.875rem;
  line-height: 1.429;
  letter-spacing: 0.006rem;
  font-weight: 500;
}

/* Label styles are smaller, utilitarian styles, used for things like the text inside components
or for very small text in the content body, such as captions. */
@mixin --m3-label-large {
  font-family: var(--m3-font);
  font-size: 0.875rem;
  line-height: 1.429;
  letter-spacing: 0.006rem;
  font-weight: 500;
}
@mixin --m3-label-medium {
  font-family: var(--m3-font);
  font-size: 0.75rem;
  line-height: 1.333;
  letter-spacing: 0.031rem;
  font-weight: 500;
}
@mixin --m3-label-small {
  font-family: var(--m3-font);
  font-size: 0.688rem;
  line-height: 1.455;
  letter-spacing: 0.031rem;
  font-weight: 500;
}

/* Body styles are used for longer passages of text in your app. */
@mixin --m3-body-large {
  font-family: var(--m3-font);
  font-size: 1rem;
  line-height: 1.5;
  letter-spacing: 0;
  font-weight: 400;
}
@mixin --m3-body-medium {
  font-family: var(--m3-font);
  font-size: 0.875rem;
  line-height: 1.429;
  letter-spacing: 0.016rem;
  font-weight: 400;
}
@mixin --m3-body-small {
  font-family: var(--m3-font);
  font-size: 0.75rem;
  line-height: 1.333;
  letter-spacing: 0.025rem;
  font-weight: 400;
}

/* Button resets to normalize browser defaults */
@mixin --m3-button-reset {
  border: none;
  background: transparent;
  padding: 0;
  cursor: pointer;
}

/* For buttons that should behave like containers (stretch, inherit text styles) */
@mixin --m3-button-reset-container {
  @apply --m3-button-reset;
  text-align: inherit;
  font: inherit;
  letter-spacing: inherit;
}

@layer base {
  /* Reset a few things */
  *,
  *::before,
  *::after {
    box-sizing: inherit;
  }
  .m3-container {
    box-sizing: border-box;
    -webkit-tap-highlight-color: transparent;
  }
  .m3-container a,
  a.m3-container {
    text-decoration: none;
  }
  .m3-container dialog,
  dialog.m3-container {
    margin: auto;
  }

  :root {
    accent-color: var(--m3c-primary);
  }
}

/* Emphasized easing timing function derived from this code:
const createBezierLUT = (points: number[][], pointCount: number = 100): number[][] => {
const lut: number[][] = [];
for (let t = 0; t < 1; t += 1 / pointCount) {
  const a = (1 - t) * (1 - t) * (1 - t);
  const b = (1 - t) * (1 - t) * t;
  const c = (1 - t) * t * t;
  const d = t * t * t;
  const x = a * points[0][0] + 3 * b * points[1][0] + 3 * c * points[2][0] + d * points[3][0];
  const y = a * points[0][1] + 3 * b * points[1][1] + 3 * c * points[2][1] + d * points[3][1];
  lut.push([x, y]);
}
return lut;
};

const createCSSEaseOptimized = (
lutOptions: number[][][],
maxErrorThreshold: number = 0.01
): string => {
// Create the full lookup table
const lut = lutOptions.map((args) => createBezierLUT(args)).flat();

// Find key points using Douglas-Peucker algorithm
const keyPoints: number[][] = [lut[0], lut[lut.length - 1]];
const segments: number[][] = [[0, lut.length - 1]];

while (segments.length > 0) {
  const [startIdx, endIdx] = segments.pop() || [0, 0];
  let maxError = 0;
  let maxErrorIdx = -1;

  // Skip if segment is too small
  if (endIdx - startIdx <= 1) continue;

  const [startX, startY] = lut[startIdx];
  const [endX, endY] = lut[endIdx];

  // Find point with maximum error
  for (let i = startIdx + 1; i < endIdx; i++) {
    const [x, y] = lut[i];

    // Linear interpolation
    const t = (x - startX) / (endX - startX);
    const interpolatedY = startY + t * (endY - startY);

    const error = Math.abs(y - interpolatedY);

    if (error > maxError) {
      maxError = error;
      maxErrorIdx = i;
    }
  }

  // If error exceeds threshold, add point and split segment
  if (maxError > maxErrorThreshold) {
    keyPoints.push(lut[maxErrorIdx]);
    segments.push([startIdx, maxErrorIdx]);
    segments.push([maxErrorIdx, endIdx]);
  }
}

// Sort by x value
keyPoints.sort((a, b) => a[0] - b[0]);

// Format result using CSS linear() with explicit percentages
let result = "linear(";

// First point (no percentage for first point)
result += keyPoints[0][1].toFixed(3);

// Middle points with explicit percentages
for (let i = 1; i < keyPoints.length - 1; i++) {
  const [x, y] = keyPoints[i];
  const percentage = (x * 100).toFixed(0) + "%";
  result += `, ${y.toFixed(3)} ${percentage}`;
}

// Last point (no percentage for last point)
result += `, ${keyPoints[keyPoints.length - 1][1].toFixed(3)}`;
result += ")";

return result;
};

// Example usage
const testInput = [
[
  [0, 0],
  [0.05, 0],
  [0.133, 0.06],
  [0.166, 0.4],
],
[
  [0.166, 0.4],
  [0.208, 0.82],
  [0.25, 1],
  [1, 1],
],
];

// Run optimized function with a more relaxed threshold for smaller size
const optimizedSmallResult = createCSSEaseOptimized(testInput, 0.01);
console.log("Optimized result (relaxed threshold 0.01):");
console.log(optimizedSmallResult);
*/
/* Zeno timing function derived from this code:
// 1) define the original mapping f(y)=time-%, capped at 100% for y=1
const whenReached = (y) => Math.log(1 - y) / Math.log(0.5);
const makePoints = () => {
  const pts = [];
  for (let i = 0; i < 100; i++) {
    const v = i / 100;
    const t = (whenReached(v) * 100) / 8;
    pts.push([v, t]);
  }
  // add the final point (1, 100)
  pts.push([1, 100]);
  return pts;
};

// 2) helper: compute perpendicular distance from pt to line (p0â†’p1)
const perpDist = (pt, p0, p1) => {
  const [x, y] = pt;
  const [x1, y1] = p0;
  const [x2, y2] = p1;
  const num = Math.abs((y2 - y1) * x - (x2 - x1) * y + x2 * y1 - y2 * x1);
  const den = Math.hypot(y2 - y1, x2 - x1);
  return den === 0 ? 0 : num / den;
};

// 3) RDP (recursive)
function rdp(points, eps) {
  if (points.length < 3) return points;
  let maxD = 0,
    idx = 0;
  for (let i = 1; i < points.length - 1; i++) {
    const d = perpDist(points[i], points[0], points[points.length - 1]);
    if (d > maxD) {
      maxD = d;
      idx = i;
    }
  }
  if (maxD > eps) {
    const left = rdp(points.slice(0, idx + 1), eps);
    const right = rdp(points.slice(idx), eps);
    return left.slice(0, -1).concat(right);
  }
  return [points[0], points[points.length - 1]];
}

// 4) round x to 2 decimals (keep trailing zeros); round y to 2 decimals (cap tiny negatives to 0)
const fmt = (v, t) => {
  const xv = v.toFixed(2);
  let tv = Math.round(t * 100) / 100; // round to 2 decimals
  if (Math.abs(tv) < 1e-8) tv = 0; // avoid "-0.00"
  return `${xv} ${tv.toFixed(2)}%`;
};

// 5) put it all together
function buildCompressedLinear(tolerance) {
  const raw = makePoints();
  const reduced = rdp(raw, tolerance);
  return `linear(${reduced.map(([v, t]) => fmt(v, t)).join(", ")})`;
}

// 6) example result
const compressed = buildCompressedLinear(0.001);
console.log(compressed);
*/
